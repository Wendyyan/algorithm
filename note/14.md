
## 14 | 排序优化：如何实现一个通用的、高性能的排序函数？

### 一、算法比较：

|       | 时间复杂度  | 是否稳定排序  | 是否原地排序(空间复杂度O(1)) |
|-------|------------|-------------|-------------------|
|冒泡排序|   O(n2)    |     是      |     是            |
|插入排序|   O(n2)    |     是      |     是            |
|选择排序|   O(n2)    |     否      |     是            |
|快速排序|   O(nlogn) |     否      |     是            |
|归并排序|   O(nlogn) |     是      |     否            |
|桶排序  |   O(n)     |     是      |     否            |
|计数排序|O(n+k)(k是数据范围)|   是   |     否            |
|基数排序|O(dn)(d是维度)|     是     |     否            |

### 二、如何优化快速排序？

合理分区，使被分区点分开的两个分区中，数据的数量差不多。

两种比较常用简单的分区算法：

1. 三数取中法

2. 随机法

### 三、分析Arrays.sort()

#### 1. Arrays.sort(int[] a):

* a.length >= 286 且连续性好的话，就用归并排序;

* a.length >= 286且连续性不好的话，就用双轴快速排序;

* a.length < 286 && a.length >= 47的话，就用双轴快速排序;

* a.length < 47的话，就用插入排序

#### 2. Arrays.sort(T[] a, Comparator<? super T> var1)

不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来。

* a.length < 32, 采用二分查找插入排序(Binary Sort)

* a.length >= 32, 采用归并排序，归并的核心是分区(Run)

* 找连续升或降的序列作为分区，分区最终被调整为升序后压入栈

*  如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值

* 每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并

* 最终栈内的分区被全部合并，得到一个排序好的数组



