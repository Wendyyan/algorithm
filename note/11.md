

## 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？

#### 排序算法的执行效率

1. 最好情况，最坏情况，平均情况时间复杂度

2. 时间复杂度的系数，常数，低阶

3. 比较次数和交换（或移动）次数

#### 排序算法的内存消耗

算法的内存消耗可以通过空间复杂度衡量。
**原地排序**算法：特指空间复杂度为O(1)的排序算法。

#### 排序算法的稳定性

**稳定性**：如果待排序的序列种存在值相等的元素，经过某种排序算法排序之后，相等元素之间原有的先后顺序不变，那我们把这种排序算法就叫做稳定的排序算法；反之先后顺序发生改变，则对应的排序算法就叫做不稳定的排序算法。

### 冒泡、插入、选择排序比较

#### 1. 冒泡排序

代码实现：
```
    /**
     * 冒泡排序，空间复杂度O(1),时间复杂度O(n2)
     */
    private void bubbleSort(int[] a, int n) {
        if (n <= 1) {
            return;
        }
        for (int i = 0; i < n; i++) {
            boolean flag = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (a[j] > a[j + 1]) {
                    int tmp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tmp;
                    flag = true;//表示有数据交换
                }
            }
            if (!flag) {//没有数据交换，提前退出
                break;
            }
        }
    }
```

#### 2. 插入排序

代码实现：

```
    /**
     * 插入排序,空间复杂度O(1),时间复杂度O(n2)
     */
    private void insertSort(int[] a, int n){
        if (n < 1) {
            return;
        }
        for (int i = 1; i < n; i++) {
            int value = a[i];
            int j = i - 1;
            for (; j >= 0; j--) {
                if (a[j] > value) {
                    a[j + 1] = a[j];
                } else {
                    break;
                }
            }
            a[j + 1] = value;
        }
    }
```

#### 3. 选择排序

代码实现：

```
    /**
     * 选择排序,空间复杂度O(1),时间复杂度O(n2)
     */
    private void selectSort(int[] a, int n) {
        if (n <= 1) {
            return;
        }
        for (int i = 0; i < n - 1; i++) {
            int k = i;
            for (int j = i + 1; j < n; j++) {
                if (a[j] < a[k]) {
                    k = j;
                }
            }
            if (k > i) {
                int tmp = a[i];
                a[i] = a[k];
                a[k] = tmp;
            }
        }
    }
```


#### 冒泡 vs 插入 vs 选择

|       | 是原地排序? | 是否稳定？ | 最好时间复杂度  | 最坏时间复杂度 | 平均时间复杂度|
|-------|------------|-----------|------|-----|----|
|冒泡排序|     是     |  是        | O(n) | O(n2)| O(n2)|
|插入排序|     是     |  是        | O(n) | O(n2)| O(n2)|
|选择排序|     是     |  否        | O(n2)|O(n2) |O(n2) |


### 解答：为什么插入排序比冒泡排序更受欢迎?

冒泡排序不管怎么优化，元素交换的次数是原始数据的逆序度；插入排序同样，不管怎么优化元素移动的次数也等于原始数据的逆序度。但是，从代码实现上看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

```
//冒泡排序中的数据交换操作
if (a[j] > a[j + 1]) {
    int tmp = a[j];
    a[j] = a[j + 1];
    a[j + 1] = tmp;
    flag = true;//表示有数据交换
}

//插入排序中的数据移动操作
if (a[j] > value) {
    a[j + 1] = a[j];
} else {
    break;
}
```